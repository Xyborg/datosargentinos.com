<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safe ID - Comparte tu DNI de Forma Segura - Datos Argentinos</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <meta name="description" content="Comparte tu DNI de forma seguro agregando una marca de agua y ofuscando tus datos sensibles.">
    <base href="https://safeid.datosargentinos.com/">
    <meta property="og:url" content="https://datosargentinos.com">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Safe ID - Comparte tu DNI de Forma Segura - Datos Argentinos">
    <meta property="og:description" content="Comparte tu DNI de forma seguro agregando una marca de agua y ofuscando tus datos sensibles.">
    <meta property="og:image" content="https://datosargentinos.com/ogimage.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:creator" content="@Xyborg">
    <meta property="twitter:url" content="https://datosargentinos.com">
    <meta name="twitter:title" content="Safe ID - Comparte tu DNI de Forma Segura - Datos Argentinos">
    <meta name="twitter:description" content="Comparte tu DNI de forma seguro agregando una marca de agua y ofuscando tus datos sensibles.">
    <meta name="twitter:image" content="https://datosargentinos.com/ogimage.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        .transition-colors,.transition-transform{transition-timing-function:cubic-bezier(0.4,0,0.2,1)}.comparison-slider img,.comparison-slider-wrapper>img{left:0;height:100%;object-fit:cover;pointer-events:none}*,::after,::before{box-sizing:border-box;border:0 solid #e5e7eb;margin:0;padding:0}body{font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:1.5;color:#1f2937;background:linear-gradient(135deg,#f0f7ff 0%,#fff7ed 100%);min-height:100vh}:root{--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-blur:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-invert:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-opacity:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-sepia:var(--tw-empty,/*!*/ /*!*/)}.max-h-40{max-height:10rem}.opacity-75{opacity:.75}.opacity-90{opacity:.9}.select-none{user-select:none;-webkit-user-select:none}.pointer-events-none{pointer-events:none}.pointer-events-auto,.slider-handle{pointer-events:auto}.whitespace-nowrap{white-space:nowrap}.break-words{word-wrap:break-word}.break-all{word-break:break-all}.hidden{display:none}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.flex-col{flex-direction:column}.relative{position:relative}.absolute{position:absolute}.inset-0{top:0;right:0;bottom:0;left:0}.top-1\/2{top:50%}.right-4{right:1rem}.w-full{width:100%}.h-12,.w-12{width:3rem}.w-5{width:1.25rem}.h-20{height:5rem}.h-5{height:1.25rem}.h-2{height:.5rem}.max-w-4xl{max-width:56rem}.min-h-screen{min-height:100vh}.transform{transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1\/2{--tw-translate-y:-50%;transform:var(--tw-transform)}.hover\:scale-105:hover{--tw-scale-x:1.05;--tw-scale-y:1.05;transform:var(--tw-transform)}.p-8{padding:2rem}.p-4{padding:1rem}.p-3{padding:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pt-8{padding-top:2rem}.pb-20{padding-bottom:5rem}.pr-16{padding-right:4rem}.mt-auto{margin-top:auto}.mt-12{margin-top:3rem}.mt-8{margin-top:2rem}.mt-6,.space-y-6>*+*{margin-top:1.5rem}.mt-2{margin-top:.5rem}.mb-16{margin-bottom:4rem}.mb-8{margin-bottom:2rem}.mb-6{margin-bottom:1.5rem}.mb-4{margin-bottom:1rem}.mb-2{margin-bottom:.5rem}.mr-2{margin-right:.5rem}.mx-auto{margin-left:auto;margin-right:auto}.space-y-4>*+*{margin-top:1rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.font-medium{font-weight:500}.text-center{text-align:center}.text-white{color:#fff}.hover\:text-gray-800:hover,.text-gray-800{color:#1f2937}.text-gray-600{color:#4b5563}.text-gray-500{color:#6b7280}.text-gray-400{color:#9ca3af}.text-blue-600{color:#2563eb}.text-purple-700{color:#6d28d9}.bg-white{background-color:#fff}.bg-blue-50{background-color:#eff6ff}.bg-purple-50{background-color:#f5f3ff}.bg-purple-200{background-color:#ddd6fe}.bg-gradient-to-br{background-image:linear-gradient(to bottom right,var(--tw-gradient-stops))}.from-gray-50{--tw-gradient-from:#f9fafb;--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to,#f9fafb)}.to-gray-100{--tw-gradient-to:#f3f4f6}.border{border-width:1px}.border-gray-300{border-color:#d1d5db}.rounded-2xl{border-radius:1rem}.rounded-lg{border-radius:.5rem}.shadow-xl{--tw-shadow:0 20px 25px -5px rgba(0,0,0,0.1),0 10px 10px -5px rgba(0,0,0,0.04);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.canvas-container,.comparison-slider-wrapper{box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06);overflow:hidden}.cursor-pointer{cursor:pointer}.cursor-crosshair{cursor:crosshair}.appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.transition-colors{transition-property:background-color,border-color,color,fill,stroke;transition-duration:.2s}.transition-transform{transition-property:transform;transition-duration:.3s}.duration-200{transition-duration:.2s}.duration-300{transition-duration:.3s}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.focus\:ring-blue-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgba(59,130,246,var(--tw-ring-opacity))}.focus\:border-transparent:focus{border-color:transparent}.items-center{align-items:center}.transition-all{transition:.3s ease-in-out}.custom-file-upload{border:2px dashed #93c5fd;border-radius:.5rem;padding:2rem;text-align:center;cursor:pointer;transition:.3s;background-color:#f0f7ff}.custom-file-upload:hover{border-color:#3b82f6;background-color:#eff6ff}.step-transition{transition:opacity .5s ease-in-out,transform .5s ease-in-out}.step-enter{opacity:0;transform:translateY(20px)}.step-enter-active{opacity:1;transform:translateY(0)}.canvas-container{border-radius:.5rem}.gradient-button{background:linear-gradient(135deg,#2563eb 0,#3b82f6 100%);transition:transform .2s,box-shadow .2s;border:none;cursor:pointer}.gradient-button:hover{transform:translateY(-1px);box-shadow:0 4px 12px rgba(37,99,235,0.3)}.slider-handle{position:absolute;top:0;bottom:0;left:50%;width:2px;background:#fff;cursor:ew-resize;transform:translateX(-50%)}.slider-handle::before{position:absolute;width:40px;height:40px;border-radius:50%;background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.3);content:'';top:50%;left:50%;transform:translate(-50%,-50%)}.slider-handle::after{position:absolute;content:'';width:24px;height:24px;top:50%;left:50%;transform:translate(-50%,-50%);background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234A5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10 19l-7-7 7-7'/%3E%3Cpath d='M14 19l7-7-7-7'/%3E%3C/svg%3E") center/contain no-repeat}.blur-button{background:linear-gradient(135deg,#f97316 0,#fb923c 100%)}.back-button{background:linear-gradient(135deg,#4b5563 0,#1f2937 100%)}.comparison-slider-wrapper{position:relative;width:100%;max-width:2xl;margin:0 auto;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#fff;aspect-ratio:1.6;overflow:hidden}.comparison-slider-wrapper>img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.comparison-slider{position:absolute;inset:0;width:50%;overflow:hidden;background-color:#fff}.comparison-slider img{position:absolute;top:0;left:0;width:200%;height:100%;object-fit:cover}.slider-handle{position:absolute;top:0;bottom:0;left:50%;width:6px;background:#abc3db;cursor:ew-resize;transform:translateX(-50%)}.slider-handle::before{position:absolute;width:40px;height:40px;border-radius:50%;background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.3)}.slider-handle::after{position:absolute;content:'';width:24px;height:24px;top:50%;left:50%;transform:translate(-50%,-50%);background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234A5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10 19l-7-7 7-7'/%3E%3Cpath d='M14 19l7-7-7-7'/%3E%3C/svg%3E") center/contain no-repeat}a{text-decoration:none}.card{background:rgba(255,255,255,0.9);backdrop-filter:blur(10px);border:1px solid rgba(148,163,184,0.1)}#downloadBtn{background:linear-gradient(135deg,#1d4ed8 0%,#3b82f6 100%)!important}#downloadBtn:hover{box-shadow:0 4px 12px rgba(29,78,216,0.3)}.highlight{background-color:#fff7ed;border-left:4px solid #f97316;padding:1rem;border-radius:.5rem}.faq-question{transition:all .3s ease}.faq-question:hover{transform:translateX(8px)}.crop-buttons-container{display:flex;justify-content:center;gap:16px;margin-top:10px}.crop-buttons-container button{min-width:140px;padding:20px;border-radius:8px;font-weight:600;transition:opacity .3s}.toolbar{display:flex;flex-wrap:wrap;gap:1rem;justify-content:center;margin-bottom:1rem;padding:.75rem;background:rgba(255,255,255,0.95);border-radius:1rem;box-shadow:0 4px 6px rgba(0,0,0,0.05);border:1px solid rgba(147,197,253,0.2)}.tool-button{display:flex;align-items:center;gap:.5rem;padding:.75rem 1.25rem;border-radius:.75rem;font-weight:500;transition:all .2s;border:1px solid transparent;background:#fff;color:#4b5563;cursor:pointer;min-width:120px;justify-content:center;box-shadow:0 2px 4px rgba(0,0,0,0.05)}.tool-button:hover{background:#f8fafc;transform:translateY(-1px);box-shadow:0 4px 6px rgba(0,0,0,0.1)}.tool-button.active{background:#dbeafe;border-color:#93c5fd;color:#2563eb}.tool-button svg{width:1.5rem;height:1.5rem}.controls-panel{background:#fff;padding:1.5rem;border-radius:1rem;margin-top:1rem;box-shadow:0 4px 6px rgba(0,0,0,0.05);border:1px solid rgba(147,197,253,0.2)}.controls-panel .buttons-container{display:flex;justify-content:center;gap:1rem;margin-top:1rem}#enableCropBtn{background:#fae8ff;color:#9333ea;border-color:#e9d5ff}#enableCropBtn:hover,#enableCropBtn.active{background:#f3e8ff;border-color:#d8b4fe;color:#7e22ce}#enableBlurBtn{background:#f0fdf4;color:#15803d;border-color:#dcfce7}#enableBlurBtn:hover,#enableBlurBtn.active{background:#dcfce7;border-color:#86efac;color:#15803d}#nextToWatermarkBtn{background:#eff6ff;color:#2563eb;border-color:#dbeafe}#nextToWatermarkBtn:hover{background:#dbeafe;border-color:#93c5fd;color:#1d4ed8}#applyCropBtn{background:#f0fdf4;color:#16a34a;border-color:#dcfce7}#applyCropBtn:hover{background:#dcfce7;border-color:#86efac;color:#15803d}#cancelCropBtn{background:#fef2f2;color:#dc2626;border-color:#fee2e2}#cancelCropBtn:hover{background:#fee2e2;border-color:#fca5a5;color:#b91c1c}#undoBlurBtn{background:#fff7ed;color:#ea580c;border-color:#ffedd5}#undoBlurBtn:hover:not(:disabled){background:#ffedd5;border-color:#fed7aa;color:#c2410c}#undoBlurBtn:disabled{opacity:.5;cursor:not-allowed}.slider-control{display:flex;flex-direction:column;gap:.5rem;margin-bottom:1.5rem;background:#f8fafc;padding:1rem;border-radius:.75rem;border:1px solid rgba(147,197,253,0.2)}.slider-control input[type="range"]{width:100%;height:.5rem;-webkit-appearance:none;background:#e2e8f0;border-radius:.25rem;outline:none}.slider-control input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:1.5rem;height:1.5rem;background:#3b82f6;border:2px solid #fff;border-radius:50%;cursor:pointer;transition:all .2s;box-shadow:0 2px 4px rgba(0,0,0,0.1)}.slider-control input[type="range"]::-webkit-slider-thumb:hover{transform:scale(1.1);box-shadow:0 4px 6px rgba(0,0,0,0.1)}.slider-control label{color:#4b5563;font-weight:500}#blurInstructions{background: #fcefdc42;color: #805215;padding:1rem;margin-top:1rem;text-align:center}@media (max-width: 640px){.toolbar{gap:.75rem;padding:.75rem;flex-direction:column}.tool-button{width:100%;padding:.75rem 1rem;justify-content:center}.tool-button svg{width:1.25rem;height:1.25rem}.controls-panel{padding:1rem}.buttons-container{flex-direction:column;gap:.75rem}.buttons-container .tool-button{width:100%}}
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QHR9LGCNE8"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-QHR9LGCNE8');
    </script>
</head>
<body class="flex flex-col items-center pt-8 pb-20">
    <div class="w-full max-w-4xl p-8 card rounded-2xl shadow-xl text-center mb-16 relative">
        <div class="absolute top-4 right-4 text-sm">
            <a href="/" class="text-gray-800">Español</a>
            <span class="text-gray-400 mx-2">|</span>
            <a href="/index-en.html" class="text-blue-600 hover:text-gray-800">English</a>
        </div>
        <a href="https://datosargentinos.com" title="Safe ID - Comparte tu DNI de Forma Segura - Datos Argentinos" class="mt-8 block">
            <img src="/logo.png" alt="Safe ID - Comparte tu DNI de Forma Segura - Datos Argentinos" class="mx-auto mb-6 h-20 transform hover:scale-105 transition-transform duration-300">
        </a>
        <h1 class="text-4xl font-bold mb-8 text-gray-800">Comparte tu DNI de Forma Segura</h1>
        <!-- Step 1: Upload and Text -->
        <div id="step1" class="space-y-6 step-transition">
            <label class="custom-file-upload block">
                <input type="file" id="imageInput" accept=".jpg,.jpeg,.png" class="hidden">
                <svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <p class="text-lg text-gray-600">Arrastra tu imagen o toca aquí para subirla</p>
                <p class="text-sm text-gray-500 mt-2">Soporta: JPG y PNG</p>
            </label>
            <div class="relative">
                <div class="relative">
                    <input type="text" id="watermarkText" maxlength="60" placeholder="Ingresa el texto de la marca de agua (máx. 60 caracteres)" 
                            class="w-full p-4 pr-16 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all text-center text-lg">
                    <span class="absolute right-4 top-1/2 -translate-y-1/2 text-sm text-gray-500">
                        <span id="charCount">0</span>/60
                    </span>
                </div>
                <p class="mt-2 text-sm text-gray-600 bg-blue-50 p-3 rounded-lg">
                    <strong>Tip Marca de Agua:</strong> Para mayor seguridad, incluye el nombre completo del destinatario y el motivo específico (ej: "Para Juan Pérez - Validación de identidad en Banco XYZ")
                </p>
            </div>

            <button id="nextToPreviewBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold hover:opacity-90">
                Siguiente
            </button>

            <div class="mt-4 text-center">
                <p class="text-sm text-gray-600">Tu documento se procesa localmente, sin enviar información a servidores externos.</p>
            </div>
        </div>

        <!-- Step 2: Preview and Blur -->
        <div id="step2" class="hidden step-transition">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Editar Imagen</h2>
                <div class="canvas-container">
                    <canvas id="originalCanvas" class="w-full cursor-crosshair"></canvas>
                </div>
            </div>
            
            <div class="toolbar">
                <button id="enableCropBtn" class="tool-button tooltip" data-tooltip="Recortar la imagen">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4v16M17 4v16M3 8h18M3 16h18" />
                    </svg>
                    <span>Recortar Imagen</span>
                </button>
                
                <button id="enableBlurBtn" class="tool-button tooltip" data-tooltip="Ofuscar datos sensibles">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                    </svg>
                    <span>Ofuscar Datos</span>
                </button>
                
                <button id="nextToWatermarkBtn" class="tool-button tooltip" data-tooltip="Continuar con la marca de agua">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Aplicar Marca de Agua</span>
                </button>
            </div>

            <div id="cropControls" class="controls-panel hidden">
                <p class="text-sm font-medium text-gray-700 mb-4 text-center">Arrastra las esquinas azules para ajustar el área de recorte</p>
                <div class="buttons-container">
                    <button id="applyCropBtn" class="tool-button">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                        </svg>
                        <span>Aplicar</span>
                    </button>
                    <button id="cancelCropBtn" class="tool-button">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                        <span>Cancelar</span>
                    </button>
                </div>
            </div>
            <div id="blurInstructions" class="bg-blue-50 text-blue-700 p-4 rounded-lg mt-4 hidden">
                Haz clic y arrastra para ofuscar áreas sensibles.<br /><span style="font-size: 0.8rem;">Ejemplo: Número de trámite, Códigos de barras/QR, Información innecesaria.</span>
            </div>
            <div id="blurControls" class="controls-panel hidden">
                <div class="slider-control">
                    <label class="text-sm font-medium text-gray-700">
                        Intensidad de Ofuscación: <span id="blurValue">10</span>
                    </label>
                    <input type="range" id="blurIntensity" min="3" max="15" value="10">
                </div>
                
                <div class="slider-control">
                    <label class="text-sm font-medium text-gray-700">
                        Tamaño del Cursor: <span id="cursorSizeValue">10</span>px
                    </label>
                    <input type="range" id="cursorSize" min="5" max="50" value="10">
                </div>
                
                <button id="undoBlurBtn" class="tool-button w-full" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
                    </svg>
                    <span>Deshacer Última Ofuscación</span>
                </button>
            </div>

        </div>

        <!-- Step 3: Final Result -->
        <div id="step3" class="hidden step-transition">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Resultado Final</h2>
                <div class="canvas-container">
                    <canvas id="canvas" class="w-full"></canvas>
                </div>
            </div>
            <button id="shareBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold mb-4" style="background: linear-gradient(135deg, #059669 0%, #10b981 100%)">
                Compartir Imagen
            </button>
            <button id="downloadBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold">
                Descargar Imagen
            </button>
            <a href="#" id="startOverBtn" class="block mt-12 text-gray-600 hover:text-gray-800 text-base transition-colors duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Volver a empezar
            </a>
        </div>
    </div>

    <footer class="w-full py-4 text-center text-gray-600 text-sm mt-auto">
        Desarrollado por <a href="https://datosargentinos.com/sobre-mi.html" class="text-blue-600 hover:text-gray-800">Martin Aberastegue</a>. Código Fuente: <a href="https://github.com/Xyborg/datosargentinos.com" class="text-blue-600 hover:text-gray-800" target="_blank" rel="noopener noreferrer">GitHub</a>
    </footer>
    <a href="https://www.iubenda.com/privacy-policy/69980701" class="iubenda-white iubenda-noiframe iubenda-embed iubenda-noiframe" target="_blank" rel="noopener noreferrer" title="Política de Privacidad">Política de Privacidad</a><script type="text/javascript">(function (w,d) {var loader = function () {var s = d.createElement("script"), tag = d.getElementsByTagName("script")[0]; s.src="https://cdn.iubenda.com/iubenda.js"; tag.parentNode.insertBefore(s,tag);}; if(w.addEventListener){w.addEventListener("load", loader, false);}else if(w.attachEvent){w.attachEvent("onload", loader);}else{w.onload = loader;}})(window, document);</script>

    <script>
        /**
         * SAFE ID - Herramienta de Protección de DNI
         * 
         * Esta herramienta procesa las imágenes completamente en el navegador del usuario.
         * No se realiza ninguna carga de imágenes a servidores externos.
         * Todo el procesamiento de imágenes y datos se realiza localmente.
         */

        // Referencias a elementos del DOM para la interfaz de usuario
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const nextToPreviewBtn = document.getElementById('nextToPreviewBtn');
        const nextToWatermarkBtn = document.getElementById('nextToWatermarkBtn');
        const enableBlurBtn = document.getElementById('enableBlurBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const blurInstructions = document.getElementById('blurInstructions');
        
        /**
         * Configuración de los canvases para el procesamiento de imágenes
         * Se utilizan dos canvases:
         * - originalCanvas: mantiene la imagen original con las áreas ofuscadas
         * - canvas: muestra el resultado final con la marca de agua
         * 
         * willReadFrequently: true -> Optimiza el rendimiento para operaciones frecuentes de lectura de píxeles
         */
        const originalCanvas = document.getElementById('originalCanvas');
        const originalCtx = originalCanvas.getContext('2d', { willReadFrequently: true });
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Variables de estado para el control de la aplicación
        let img = new Image();           // Almacena la imagen cargada
        let painting = false;            // Controla el estado de pintado/ofuscación
        let blurEnabled = false;         // Controla si el modo ofuscación está activo
        
        /**
         * Configuración de calidad para el procesamiento de imágenes
         * Asegura que las imágenes mantengan la mejor calidad posible durante el procesamiento
         */
        originalCtx.imageSmoothingEnabled = true;
        originalCtx.imageSmoothingQuality = 'high';
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        /**
         * Sistema de contador de caracteres para la marca de agua
         * Limita y muestra la cantidad de caracteres ingresados (máximo 60)
         */
        const watermarkInput = document.getElementById('watermarkText');
        const charCount = document.getElementById('charCount');
        
        watermarkInput.addEventListener('input', function() {
            charCount.textContent = this.value.length;
        });

        /**
         * Manejador de carga de imágenes
         * - Valida el tipo de archivo (solo JPG y PNG)
         * - Procesa la imagen localmente sin enviarla a ningún servidor
         * - Muestra una vista previa en la interfaz
         */
        document.getElementById('imageInput').addEventListener('change', function(e) {
            if (e.target.files[0]) {
                const file = e.target.files[0];
                const fileLabel = this.parentElement.querySelector('p');
                
                // Validación de seguridad: solo permite formatos de imagen seguros
                const validTypes = ['image/jpeg', 'image/jpg', 'image/png'];
                if (!validTypes.includes(file.type)) {
                    alert('Por favor sube un archivo en formato JPG o PNG');
                    this.value = ''; // Limpia el input por seguridad
                    return;
                }
                
                fileLabel.textContent = file.name;
                
                // Procesamiento local de la imagen para vista previa
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewImg = document.createElement('img');
                    previewImg.src = e.target.result;
                    previewImg.classList.add('mx-auto', 'mt-4', 'max-h-40', 'rounded-lg');
                    
                    const existingPreview = fileLabel.parentElement.querySelector('img');
                    if (existingPreview) {
                        existingPreview.remove();
                    }
                    
                    fileLabel.parentElement.appendChild(previewImg);
                };
                reader.readAsDataURL(file);
            }
        });

        /**
         * Sistema de transición entre pasos
         * Maneja la visibilidad y animaciones entre las diferentes etapas del proceso
         */
        function showStep(stepToShow) {
            [step1, step2, step3].forEach(step => {
                if (step === stepToShow) {
                    step.classList.remove('hidden');
                    step.classList.add('step-enter');
                    setTimeout(() => step.classList.add('step-enter-active'), 10);
                } else {
                    step.classList.add('hidden');
                    step.classList.remove('step-enter', 'step-enter-active');
                }
            });
        }

        /**
         * Cargador de imágenes seguro
         * - Procesa la imagen manteniendo las dimensiones originales
         * - No reduce la calidad de la imagen
         * - Mantiene todo el procesamiento en el dispositivo del usuario
         */
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                img = new Image();
                img.onload = function () {
                    // Mantiene las dimensiones originales para no perder calidad
                    originalCanvas.width = canvas.width = img.width;
                    originalCanvas.height = canvas.height = img.height;
                    originalCtx.drawImage(img, 0, 0, img.width, img.height);
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    
                    // Ajusta el tamaño visual manteniendo la proporción
                    originalCanvas.style.width = canvas.style.width = '100%';
                    originalCanvas.style.height = canvas.style.height = 'auto';
                    originalCanvas.style.maxWidth = canvas.style.maxWidth = '100%';
                };
                img.onerror = function() {
                    alert('Error al cargar la imagen. Por favor intenta con otro archivo.');
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                alert('Error al leer el archivo. Por favor intenta de nuevo.');
            };
            reader.readAsDataURL(file);
        }

        /**
         * Validación y procesamiento del paso inicial
         * Verifica que se hayan proporcionado todos los datos necesarios
         */
        nextToPreviewBtn.addEventListener('click', () => {
            const imageInput = document.getElementById('imageInput');
            const watermarkText = watermarkInput.value;
            
            if (!imageInput.files[0]) {
                alert('Por favor sube una imagen primero.');
                return;
            }
            if (!watermarkText.trim()) {
                alert('Por favor ingresa el texto de la marca de agua.');
                return;
            }
            if (watermarkText.length > 60) {
                alert('El texto de la marca de agua debe ser de 60 caracteres o menos.');
                return;
            }

            loadImage(imageInput.files[0]);
            showStep(step2);
        });

        /**
         * Sistema de recorte de imagen
         * Permite al usuario seleccionar y recortar una porción específica de la imagen
         */
        let cropEnabled = false;
        let cropBox = null;
        let originalImageData = null;
        let corners = [];

        // Elementos del DOM para el recorte
        const enableCropBtn = document.getElementById('enableCropBtn');
        const cropControls = document.getElementById('cropControls');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');

        function createCropBox() {
            cropBox = document.createElement('div');
            cropBox.style.position = 'absolute';
            cropBox.style.width = '100%';
            cropBox.style.height = '100%';
            cropBox.style.top = '0';
            cropBox.style.left = '0';
            cropBox.style.pointerEvents = 'none';
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.style.position = 'absolute';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.pointerEvents = 'none';
            
            // Set the SVG viewport
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('preserveAspectRatio', 'none');
            
            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            polygon.setAttribute('fill', 'rgba(6, 182, 212, 0.1)');
            polygon.setAttribute('stroke', '#06b6d4');
            polygon.setAttribute('stroke-width', '0.5');
            polygon.style.pointerEvents = 'none';
            svg.appendChild(polygon);
            cropBox.appendChild(svg);
            
            const canvasContainer = originalCanvas.parentElement;
            canvasContainer.style.position = 'relative';
            canvasContainer.appendChild(cropBox);

            // Calculate initial corner positions with padding relative to canvas size
            const rect = originalCanvas.getBoundingClientRect();
            const padding = Math.min(rect.width, rect.height) * 0.1; // 10% padding
            
            // Store corners in relative coordinates (0-1) for better scaling
            corners = [
                { x: padding / rect.width, y: padding / rect.height }, // Top-left
                { x: (rect.width - padding) / rect.width, y: padding / rect.height }, // Top-right
                { x: (rect.width - padding) / rect.width, y: (rect.height - padding) / rect.height }, // Bottom-right
                { x: padding / rect.width, y: (rect.height - padding) / rect.height } // Bottom-left
            ];

            // Create corner handles
            corners.forEach((corner, index) => {
                const handle = document.createElement('div');
                handle.className = 'corner-handle';
                handle.style.position = 'absolute';
                handle.style.width = '20px'; // Increased size for better touch
                handle.style.height = '20px'; // Increased size for better touch
                handle.style.backgroundColor = '#06b6d4';
                handle.style.border = '2px solid white';
                handle.style.borderRadius = '50%';
                handle.style.cursor = 'move';
                handle.style.zIndex = '10';
                handle.style.transform = 'translate(-50%, -50%)';
                handle.style.pointerEvents = 'auto';
                handle.style.touchAction = 'none'; // Prevent scrolling while dragging
                
                // Position the handle using relative coordinates
                handle.style.left = `${corner.x * 100}%`;
                handle.style.top = `${corner.y * 100}%`;
                
                // Mouse Events
                handle.addEventListener('mousedown', handleDragStart);
                
                // Touch Events
                handle.addEventListener('touchstart', handleDragStart, { passive: false });
                
                function handleDragStart(e) {
                    e.preventDefault(); // Prevent scrolling on mobile
                    e.stopPropagation();
                    const rect = originalCanvas.getBoundingClientRect();
                    
                    function moveHandle(e) {
                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                        
                        const x = Math.min(Math.max(0, (clientX - rect.left) / rect.width), 1);
                        const y = Math.min(Math.max(0, (clientY - rect.top) / rect.height), 1);
                        
                        corners[index] = { x, y };
                        handle.style.left = `${x * 100}%`;
                        handle.style.top = `${y * 100}%`;
                        
                        updatePolygon();
                    }
                    
                    function stopMoving() {
                        document.removeEventListener('mousemove', moveHandle);
                        document.removeEventListener('mouseup', stopMoving);
                        document.removeEventListener('touchmove', moveHandle);
                        document.removeEventListener('touchend', stopMoving);
                    }
                    
                    document.addEventListener('mousemove', moveHandle);
                    document.addEventListener('mouseup', stopMoving);
                    document.addEventListener('touchmove', moveHandle, { passive: false });
                    document.addEventListener('touchend', stopMoving);
                }
                
                cropBox.appendChild(handle);
            });
            
            updatePolygon();
        }

        function updatePolygon() {
            if (!cropBox) return;
            
            const polygon = cropBox.querySelector('polygon');
            if (polygon) {
                // Convert relative coordinates to SVG viewport coordinates (0-100)
                const pointsStr = corners.map(corner => {
                    const x = corner.x * 100;
                    const y = corner.y * 100;
                    return `${x},${y}`;
                }).join(' ');
                polygon.setAttribute('points', pointsStr);
            }
        }

        function disableCropMode() {
            cropEnabled = false;
            enableCropBtn.classList.remove('opacity-75');
            cropControls.classList.add('hidden');
            
            if (cropBox) {
                cropBox.remove();
                cropBox = null;
            }
        }

        function enableCropMode() {
            cropEnabled = true;
            enableCropBtn.classList.add('opacity-75');
            cropControls.classList.remove('hidden');
            originalImageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            createCropBox();
            
            // Disable blur mode if it's active
            if (blurEnabled) {
                blurEnabled = false;
                blurInstructions.style.display = 'none';
                blurControls.classList.add('hidden');
                enableBlurBtn.textContent = 'Ofuscar';
                enableBlurBtn.classList.remove('opacity-75');
            }
        }

        function applyCrop() {
            if (!cropBox) return;
            
            // Calculate the bounds of the cropped area
            const points = corners.map(corner => ({
                x: corner.x * originalCanvas.width,
                y: corner.y * originalCanvas.height
            }));
            
            // Find the bounding box of the cropped area
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            
            // Calculate new dimensions
            const newWidth = maxX - minX;
            const newHeight = maxY - minY;
            
            // Create a temporary canvas for the original image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalCanvas.width;
            tempCanvas.height = originalCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw the original image
            tempCtx.drawImage(originalCanvas, 0, 0);
            
            // Resize the original canvas to the new dimensions
            originalCanvas.width = newWidth;
            originalCanvas.height = newHeight;
            
            // Clear and set up the clipping path
            originalCtx.clearRect(0, 0, newWidth, newHeight);
            originalCtx.save();
            originalCtx.beginPath();
            
            // Adjust points relative to the new origin (minX, minY)
            points.forEach((point, index) => {
                const x = point.x - minX;
                const y = point.y - minY;
                if (index === 0) {
                    originalCtx.moveTo(x, y);
                } else {
                    originalCtx.lineTo(x, y);
                }
            });
            
            originalCtx.closePath();
            originalCtx.clip();
            
            // Draw the cropped portion of the original image
            originalCtx.drawImage(tempCanvas, -minX, -minY);
            originalCtx.restore();
            
            // Update canvas style to maintain aspect ratio
            originalCanvas.style.width = '100%';
            originalCanvas.style.height = 'auto';
            originalCanvas.style.maxWidth = '100%';
            
            disableCropMode();
        }

        // Event listeners para el recorte
        enableCropBtn.addEventListener('click', () => {
            if (cropEnabled) {
                if (originalImageData) {
                    originalCtx.putImageData(originalImageData, 0, 0);
                }
                disableCropMode();
            } else {
                enableCropMode();
            }
        });

        applyCropBtn.addEventListener('click', applyCrop);
        cancelCropBtn.addEventListener('click', () => {
            if (originalImageData) {
                originalCtx.putImageData(originalImageData, 0, 0);
            }
            disableCropMode();
        });

        // Update the crop controls text
        const cropInstructions = document.querySelector('#cropControls p');
        cropInstructions.textContent = 'Arrastra las esquinas azules para ajustar el área de recorte.';

        /**
         * Sistema de control de ofuscación
         * Permite al usuario ajustar la intensidad del efecto de blur
         */
        const blurIntensity = document.getElementById('blurIntensity');
        const blurValue = document.getElementById('blurValue');
        const cursorSize = document.getElementById('cursorSize');
        const cursorSizeValue = document.getElementById('cursorSizeValue');
        const blurControls = document.getElementById('blurControls');

        // Add state history tracking for undo
        let canvasStateHistory = [];
        let currentStateIndex = -1;
        const MAX_HISTORY_STATES = 20;
        let strokeInProgress = false;

        function saveCanvasState() {
            // Only save state if we're not in the middle of a stroke
            if (!strokeInProgress) {
                // Remove any states after current index if we branched
                canvasStateHistory = canvasStateHistory.slice(0, currentStateIndex + 1);
                
                // Save current canvas state
                const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
                
                // If we reached max history, remove oldest state
                if (canvasStateHistory.length >= MAX_HISTORY_STATES) {
                    canvasStateHistory.shift();
                    currentStateIndex--;
                }
                
                canvasStateHistory.push(imageData);
                currentStateIndex++;
                
                // Enable/disable undo button based on history
                document.getElementById('undoBlurBtn').disabled = currentStateIndex <= 0;
            }
        }

        function undoBlur() {
            if (currentStateIndex > 0) {
                currentStateIndex--;
                const previousState = canvasStateHistory[currentStateIndex];
                originalCtx.putImageData(previousState, 0, 0);
                
                // Update undo button state
                document.getElementById('undoBlurBtn').disabled = currentStateIndex <= 0;
            }
        }

        blurIntensity.addEventListener('input', function() {
            blurValue.textContent = this.value;
        });

        cursorSize.addEventListener('input', function() {
            cursorSizeValue.textContent = this.value;
        });

        /**
         * Control del modo ofuscación
         * Activa/desactiva la capacidad de ofuscar áreas sensibles
         */
        enableBlurBtn.addEventListener('click', () => {
            blurEnabled = !blurEnabled;
            blurInstructions.style.display = blurEnabled ? 'block' : 'none';
            blurControls.classList.toggle('hidden');
            //enableBlurBtn.textContent = blurEnabled ? 'Desactivar Modo Ofuscación' : 'Ofuscar Datos';
            enableBlurBtn.classList.toggle('opacity-75');
            
            if (blurEnabled) {
                // Initialize state history when enabling blur mode
                canvasStateHistory = [];
                currentStateIndex = -1;
                saveCanvasState(); // Save initial state
                
                if ('ontouchstart' in window) {
                    blurInstructions.innerHTML = 'Toca y arrastra para ofuscar áreas sensibles, luego aplica la marca de agua<br /><span style="font-size: 0.8rem;">Ejemplo: Número de trámite, Códigos de barras/QR, Información innecesaria.</span>';
                }
            }
        });

        // Add undo button event listener
        document.getElementById('undoBlurBtn').addEventListener('click', undoBlur);

        // Navegación entre pasos
        nextToWatermarkBtn.addEventListener('click', () => {
            showStep(step3);
            applyWatermark();
        });

        startOverBtn.addEventListener('click', () => {
            location.reload();
        });

        /**
         * Sistema de descarga segura
         * Genera la imagen final en el dispositivo del usuario
         * No se realiza ninguna carga a servidores externos
         */
        document.getElementById('downloadBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'safeid_datosargentinoscom.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        /**
         * Sistema de compartir
         * Utiliza la Web Share API para compartir la imagen
         * Solo disponible en navegadores y dispositivos compatibles
         */
        document.getElementById('shareBtn').addEventListener('click', async () => {
            try {
                // Convertir el canvas a un Blob para compartir
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                // Crear un archivo con el blob para compartir
                const file = new File([blob], 'safeid_datosargentinoscom.png', { type: 'image/png' });

                // Verificar si el navegador soporta Web Share API
                if (navigator.share) {
                    await navigator.share({
                        title: 'DNI Protegido',
                        text: 'DNI con marca de agua y datos protegidos via datosargentinos.com',
                        files: [file]
                    });
                } else {
                    // Fallback: Si no hay soporte para Web Share API, descargar la imagen
                    const link = document.createElement('a');
                    link.download = 'safeid_datosargentinoscom.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            } catch (error) {
                console.error('Error al compartir:', error);
                // Si hay un error en el proceso de compartir, intentar descarga directa
                const link = document.createElement('a');
                link.download = 'safeid_datosargentinoscom.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        });

        /**
         * Sistema de ofuscación interactivo
         * Implementa eventos de mouse y touch para permitir al usuario
         * ofuscar áreas específicas de la imagen de forma interactiva
         */

        // Eventos de mouse para ofuscación
        originalCanvas.addEventListener('mousedown', (event) => {
            if (blurEnabled) {
                painting = true;
                strokeInProgress = true;
                blurAtMouse(event);
            }
        });
        
        originalCanvas.addEventListener('mouseup', () => {
            painting = false;
            if (strokeInProgress) {
                strokeInProgress = false;
                saveCanvasState();
            }
        });
        originalCanvas.addEventListener('mousemove', (event) => {
            if (painting && blurEnabled) {
                blurAtMouse(event);
            }
        });

        // Eventos táctiles para ofuscación en dispositivos móviles
        originalCanvas.addEventListener('touchstart', (event) => {
            if (blurEnabled) {
                event.preventDefault(); // Prevenir scroll mientras se ofusca
                painting = true;
                strokeInProgress = true;
                blurAtTouch(event);
            }
        });

        originalCanvas.addEventListener('touchend', (event) => {
            event.preventDefault();
            painting = false;
            if (strokeInProgress) {
                strokeInProgress = false;
                saveCanvasState();
            }
        });

        originalCanvas.addEventListener('touchmove', (event) => {
            if (painting && blurEnabled) {
                event.preventDefault(); // Prevenir scroll mientras se ofusca
                blurAtTouch(event);
            }
        });

        /**
         * Funciones de cálculo de posición para ofuscación
         * Convierten las coordenadas de pantalla a coordenadas de canvas
         * considerando el escalado y posición del elemento
         */
        function blurAtMouse(event) {
            // Obtener las dimensiones y posición actual del canvas
            const rect = originalCanvas.getBoundingClientRect();
            // Calcular factores de escala para mantener precisión
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            // Convertir coordenadas del mouse a coordenadas del canvas
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            applyBlur(x, y);
        }

        function blurAtTouch(event) {
            // Obtener las dimensiones y posición actual del canvas
            const rect = originalCanvas.getBoundingClientRect();
            // Calcular factores de escala para mantener precisión
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            // Obtener el primer punto de contacto
            const touch = event.touches[0];
            // Convertir coordenadas táctiles a coordenadas del canvas
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            applyBlur(x, y);
        }

        /**
         * Algoritmo de ofuscación
         * Implementa un efecto de blur gaussiano para proteger información sensible
         * El proceso es irreversible y se realiza localmente en el dispositivo
         * @param {number} x - Coordenada X del centro del área a ofuscar
         * @param {number} y - Coordenada Y del centro del área a ofuscar
         */
        function applyBlur(x, y) {
            // Only save state before first blur in a stroke
            if (!strokeInProgress) {
                saveCanvasState();
                strokeInProgress = true;
            }
            
            // Obtener el radio del pincel de ofuscación del control de usuario
            const radius = parseInt(cursorSize.value);
            const diameter = radius * 2;
            
            // Obtener los datos de imagen del área a ofuscar
            const imageData = originalCtx.getImageData(x - radius, y - radius, diameter, diameter);
            const pixels = imageData.data;
            const centerX = radius;
            const centerY = radius;
            
            // Aplicar el efecto de blur a cada píxel dentro del radio
            for (let i = 0; i < diameter; i++) {
                for (let j = 0; j < diameter; j++) {
                    const idx = (i * diameter + j) * 4;
                    const distance = Math.sqrt(Math.pow(i - centerX, 2) + Math.pow(j - centerY, 2));
                    
                    // Solo aplicar blur a píxeles dentro del radio circular
                    if (distance <= radius) {
                        const neighbors = getNeighborPixels(pixels, i, j, diameter);
                        pixels[idx] = neighbors.r;     // Canal Rojo
                        pixels[idx + 1] = neighbors.g; // Canal Verde
                        pixels[idx + 2] = neighbors.b; // Canal Azul
                    }
                }
            }
            
            // Actualizar el canvas con los píxeles ofuscados
            originalCtx.putImageData(imageData, x - radius, y - radius);
        }

        /**
         * Función auxiliar para el cálculo de blur
         * Promedia los píxeles vecinos para crear el efecto de desenfoque gaussiano
         * @param {Uint8ClampedArray} pixels - Array de datos de píxeles
         * @param {number} x - Coordenada X del píxel central
         * @param {number} y - Coordenada Y del píxel central
         * @param {number} diameter - Diámetro del área de blur
         * @returns {Object} Valores RGB promediados para el píxel
         */
        function getNeighborPixels(pixels, x, y, diameter) {
            // Obtener la intensidad del blur del control deslizante
            const intensity = parseInt(blurIntensity.value);
            const neighbors = {
                r: 0, // Suma de valores rojos
                g: 0, // Suma de valores verdes
                b: 0, // Suma de valores azules
                count: 0 // Contador de píxeles procesados
            };

            // Recorrer los píxeles vecinos según la intensidad
            for (let i = -intensity; i <= intensity; i++) {
                for (let j = -intensity; j <= intensity; j++) {
                    const newX = x + i;
                    const newY = y + j;
                    
                    // Verificar que el píxel está dentro del área válida
                    if (newX >= 0 && newX < diameter && newY >= 0 && newY < diameter) {
                        const neighborIdx = (newX * diameter + newY) * 4;
                        neighbors.r += pixels[neighborIdx];     // Sumar valor rojo
                        neighbors.g += pixels[neighborIdx + 1]; // Sumar valor verde
                        neighbors.b += pixels[neighborIdx + 2]; // Sumar valor azul
                        neighbors.count++;
                    }
                }
            }

            // Retornar el promedio de los valores RGB
            return {
                r: neighbors.r / neighbors.count,
                g: neighbors.g / neighbors.count,
                b: neighbors.b / neighbors.count
            };
        }

        /**
         * Sistema de marca de agua
         * Aplica una marca de agua visible y persistente a la imagen
         * El proceso es irreversible y se realiza en múltiples capas
         * para prevenir la eliminación de la marca de agua
         */
        function applyWatermark() {
            // Obtener el texto de la marca de agua
            const watermarkText = watermarkInput.value;
            
            // Ajustar dimensiones del canvas final
            canvas.width = originalCanvas.width;
            canvas.height = originalCanvas.height;
            
            // Limpiar el canvas y dibujar la imagen procesada
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalCanvas, 0, 0);
            
            // Mantener proporción de aspecto en la visualización
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            canvas.style.maxWidth = '100%';
            
            // Convertir la imagen a escala de grises para mejor visibilidad de la marca de agua
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = data[i + 1] = data[i + 2] = avg;
            }
            ctx.putImageData(imageData, 0, 0);

            // Calcular tamaño de fuente adaptativo
            const minFontSize = 8;
            const maxFontSize = 22;
            const baseFontSize = Math.min(canvas.width, canvas.height) / 40;
            const fontSize = Math.min(maxFontSize, Math.max(minFontSize, baseFontSize));
            
            // Configurar estilo del texto
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            
            // Calcular espaciado para el patrón de marca de agua
            const textWidth = ctx.measureText(watermarkText).width;
            const horizontalSpacing = textWidth * 1.2;
            const verticalSpacing = fontSize * 1.2;

            // Aplicar transformación para patrón diagonal
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(-Math.PI / 6);
            ctx.translate(-canvas.width/2, -canvas.height/2);

            // Calcular área de cobertura para la marca de agua
            const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
            const startX = -diagonal/2;
            const startY = -diagonal/2;
            const endX = diagonal * 1.5;
            const endY = diagonal * 1.5;

            /**
             * Función para crear el efecto ondulado en el texto
             * Añade variación y complejidad a la marca de agua
             * para dificultar su eliminación
             * @param {string} text - Texto a dibujar
             * @param {number} x - Posición X base del texto
             * @param {number} y - Posición Y base del texto
             * @param {number} amplitude - Amplitud de la onda
             * @param {number} frequency - Frecuencia de la onda
             */
            const drawWavyText = (text, x, y, amplitude, frequency) => {
                const characters = text.split('');
                let currentX = x - (textWidth / 2);
                const baselineY = y;
                
                characters.forEach((char) => {
                    const charWidth = ctx.measureText(char).width;
                    const waveX = currentX + (charWidth / 2);
                    const yOffset = amplitude * Math.sin(frequency * waveX + baselineY * 0.05);
                    const xOffset = amplitude * 0.3 * Math.cos(frequency * waveX + baselineY * 0.05);
                    
                    // Capa de sombra para mejorar legibilidad
                    ctx.globalAlpha = 0.1;
                    ctx.fillText(char, currentX + xOffset + 1, baselineY + yOffset + 1);
                    
                    // Capa principal del texto
                    ctx.globalAlpha = 0.35;
                    ctx.fillText(char, currentX + xOffset, baselineY + yOffset);
                    
                    currentX += charWidth * 1.1;
                });
            };

            // Paleta de colores para la marca de agua
            // Colores semi-transparentes para mejor integración visual
            const colors = [
                'rgba(230, 110, 110, 0.7)',  // Light red
                'rgba(140, 171, 111, 0.7)',  // Olive green
                'rgba(230, 110, 110, 0.7)',  // Light red
                'rgba(140, 171, 111, 0.7)',  // Olive green
                'rgba(124, 128, 194, 0.7)',  // Grayish blue
                'rgba(186, 85, 211, 0.7)',   // Purple
                'rgba(255, 165, 0, 0.7)',    // Orange
                'rgba(75, 0, 130, 0.7)',     // Indigo
                'rgba(64, 224, 208, 0.7)',   // Turquoise
                'rgba(255, 20, 147, 0.7)',   // Deep pink
                'rgba(255, 215, 0, 0.7)',    // Gold
                'rgba(0, 128, 128, 0.7)',    // Teal
                'rgba(219, 112, 147, 0.7)',  // Pale pink
                'rgba(106, 90, 205, 0.7)',   // Slate blue
                'rgba(255, 99, 71, 0.7)',    // Tomato
                'rgba(147, 112, 219, 0.7)',  // Medium purple
                'rgba(60, 179, 113, 0.7)',   // Medium sea green
                'rgba(238, 130, 238, 0.7)',  // Violet
                'rgba(218, 165, 32, 0.7)',   // Dark gold
                'rgba(72, 209, 204, 0.7)',   // Medium turquoise
                'rgba(199, 21, 133, 0.7)',   // Medium magenta
                'rgba(255, 140, 0, 0.7)'     // Dark orange
            ];

            // Aplicar el patrón de marca de agua en toda la imagen
            for (let y = startY; y < endY; y += verticalSpacing) {
                // Alternar el offset horizontal en cada fila para crear patrón entrelazado
                let offsetX = (Math.floor(y / verticalSpacing) % 2) * (horizontalSpacing / 2);
                
                for (let x = startX + offsetX; x < endX; x += horizontalSpacing) {
                    // Parámetros de la onda para el texto
                    const amplitude = fontSize * 0.8;
                    const frequency = 0.04;
                    // Seleccionar color aleatorio para cada instancia del texto
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    drawWavyText(watermarkText, x, y, amplitude, frequency);
                }
            }

            // Restaurar el contexto del canvas y la opacidad
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        /**
         * Registro del Service Worker
         * Habilita la funcionalidad offline y características de PWA
         * Permite que la herramienta funcione sin conexión a internet
         */
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registrado con éxito:', registration.scope);
                        
                        // Check for updates every time the page loads
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    if (confirm('Nueva versión disponible. ¿Actualizar ahora?')) {
                                        newWorker.postMessage('skipWaiting');
                                        window.location.reload();
                                    }
                                }
                            });
                        });

                        // Check if there's an existing service worker
                        if (registration.active) {
                            registration.update();
                        }
                    })
                    .catch(error => {
                        console.log('Error al registrar el Service Worker:', error);
                    });

                // Handle updates when the service worker is already active
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    window.location.reload();
                });
            });
        }
    </script>
</body>
</html>