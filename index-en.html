<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safe ID - Share Your ID Securely - Datos Argentinos</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <meta name="description" content="Share your ID securely by adding a watermark and obscuring your sensitive data.">
    <base href="https://datosargentinos.com/">
    <meta property="og:url" content="https://datosargentinos.com">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Safe ID - Share Your ID Securely - Datos Argentinos">
    <meta property="og:description" content="Share your ID securely by adding a watermark and obscuring your sensitive data.">
    <meta property="og:image" content="https://datosargentinos.com/ogimage.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="datosargentinos.com">
    <meta property="twitter:url" content="https://datosargentinos.com">
    <meta name="twitter:title" content="Safe ID - Share Your ID Securely - Datos Argentinos">
    <meta name="twitter:description" content="Share your ID securely by adding a watermark and obscuring your sensitive data.">
    <meta name="twitter:image" content="https://datosargentinos.com/ogimage.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        .transition-colors,.transition-transform{transition-timing-function:cubic-bezier(0.4,0,0.2,1)}.comparison-slider img,.comparison-slider-wrapper>img{left:0;height:100%;object-fit:cover;pointer-events:none}*,::after,::before{box-sizing:border-box;border:0 solid #e5e7eb;margin:0;padding:0}body{font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:1.5;color:#1f2937;background:linear-gradient(135deg,#f0f7ff 0%,#fff7ed 100%);min-height:100vh}:root{--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-blur:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-invert:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-opacity:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-backdrop-sepia:var(--tw-empty,/*!*/ /*!*/)}.max-h-40{max-height:10rem}.opacity-75{opacity:.75}.opacity-90{opacity:.9}.select-none{user-select:none;-webkit-user-select:none}.pointer-events-none{pointer-events:none}.pointer-events-auto,.slider-handle{pointer-events:auto}.whitespace-nowrap{white-space:nowrap}.break-words{word-wrap:break-word}.break-all{word-break:break-all}.hidden{display:none}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.flex-col{flex-direction:column}.relative{position:relative}.absolute{position:absolute}.inset-0{top:0;right:0;bottom:0;left:0}.top-1\/2{top:50%}.right-4{right:1rem}.w-full{width:100%}.h-12,.w-12{width:3rem}.w-5{width:1.25rem}.h-20{height:5rem}.h-5{height:1.25rem}.h-2{height:.5rem}.max-w-4xl{max-width:56rem}.min-h-screen{min-height:100vh}.transform{transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1\/2{--tw-translate-y:-50%;transform:var(--tw-transform)}.hover\:scale-105:hover{--tw-scale-x:1.05;--tw-scale-y:1.05;transform:var(--tw-transform)}.p-8{padding:2rem}.p-4{padding:1rem}.p-3{padding:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.pt-8{padding-top:2rem}.pb-20{padding-bottom:5rem}.pr-16{padding-right:4rem}.mt-auto{margin-top:auto}.mt-12{margin-top:3rem}.mt-8{margin-top:2rem}.mt-6,.space-y-6>*+*{margin-top:1.5rem}.mt-2{margin-top:.5rem}.mb-16{margin-bottom:4rem}.mb-8{margin-bottom:2rem}.mb-6{margin-bottom:1.5rem}.mb-4{margin-bottom:1rem}.mb-2{margin-bottom:.5rem}.mr-2{margin-right:.5rem}.mx-auto{margin-left:auto;margin-right:auto}.space-y-4>*+*{margin-top:1rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.font-medium{font-weight:500}.text-center{text-align:center}.text-white{color:#fff}.hover\:text-gray-800:hover,.text-gray-800{color:#1f2937}.text-gray-600{color:#4b5563}.text-gray-500{color:#6b7280}.text-gray-400{color:#9ca3af}.text-blue-600{color:#2563eb}.text-purple-700{color:#6d28d9}.bg-white{background-color:#fff}.bg-blue-50{background-color:#eff6ff}.bg-purple-50{background-color:#f5f3ff}.bg-purple-200{background-color:#ddd6fe}.bg-gradient-to-br{background-image:linear-gradient(to bottom right,var(--tw-gradient-stops))}.from-gray-50{--tw-gradient-from:#f9fafb;--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to,#f9fafb)}.to-gray-100{--tw-gradient-to:#f3f4f6}.border{border-width:1px}.border-gray-300{border-color:#d1d5db}.rounded-2xl{border-radius:1rem}.rounded-lg{border-radius:.5rem}.shadow-xl{--tw-shadow:0 20px 25px -5px rgba(0,0,0,0.1),0 10px 10px -5px rgba(0,0,0,0.04);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.canvas-container,.comparison-slider-wrapper{box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06);overflow:hidden}.cursor-pointer{cursor:pointer}.cursor-crosshair{cursor:crosshair}.appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.transition-colors{transition-property:background-color,border-color,color,fill,stroke;transition-duration:.2s}.transition-transform{transition-property:transform;transition-duration:.3s}.duration-200{transition-duration:.2s}.duration-300{transition-duration:.3s}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.focus\:ring-blue-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgba(59,130,246,var(--tw-ring-opacity))}.focus\:border-transparent:focus{border-color:transparent}.items-center{align-items:center}.transition-all{transition:.3s ease-in-out}.custom-file-upload{border:2px dashed #93c5fd;border-radius:.5rem;padding:2rem;text-align:center;cursor:pointer;transition:.3s;background-color:#f0f7ff}.custom-file-upload:hover{border-color:#3b82f6;background-color:#eff6ff}.step-transition{transition:opacity .5s ease-in-out,transform .5s ease-in-out}.step-enter{opacity:0;transform:translateY(20px)}.step-enter-active{opacity:1;transform:translateY(0)}.canvas-container{border-radius:.5rem}.gradient-button{background:linear-gradient(135deg,#2563eb 0,#3b82f6 100%);transition:transform .2s,box-shadow .2s;border:none;cursor:pointer}.gradient-button:hover{transform:translateY(-1px);box-shadow:0 4px 12px rgba(37,99,235,0.3)}.slider-handle{position:absolute;top:0;bottom:0;left:50%;width:2px;background:#fff;cursor:ew-resize;transform:translateX(-50%)}.slider-handle::before{position:absolute;width:40px;height:40px;border-radius:50%;background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.3);content:'';top:50%;left:50%;transform:translate(-50%,-50%)}.slider-handle::after{position:absolute;content:'';width:24px;height:24px;top:50%;left:50%;transform:translate(-50%,-50%);background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234A5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10 19l-7-7 7-7'/%3E%3Cpath d='M14 19l7-7-7-7'/%3E%3C/svg%3E") center/contain no-repeat}.blur-button{background:linear-gradient(135deg,#f97316 0,#fb923c 100%)}.back-button{background:linear-gradient(135deg,#4b5563 0,#1f2937 100%)}.comparison-slider-wrapper{position:relative;width:100%;max-width:2xl;margin:0 auto;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#fff;aspect-ratio:1.6;overflow:hidden}.comparison-slider-wrapper>img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.comparison-slider{position:absolute;inset:0;width:50%;overflow:hidden;background-color:#fff}.comparison-slider img{position:absolute;top:0;left:0;width:200%;height:100%;object-fit:cover}.slider-handle{position:absolute;top:0;bottom:0;left:50%;width:6px;background:#abc3db;cursor:ew-resize;transform:translateX(-50%)}.slider-handle::before{position:absolute;width:40px;height:40px;border-radius:50%;background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.3)}.slider-handle::after{position:absolute;content:'';width:24px;height:24px;top:50%;left:50%;transform:translate(-50%,-50%);background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234A5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10 19l-7-7 7-7'/%3E%3Cpath d='M14 19l7-7-7-7'/%3E%3C/svg%3E") center/contain no-repeat}a{text-decoration:none}.card{background:rgba(255,255,255,0.9);backdrop-filter:blur(10px);border:1px solid rgba(148,163,184,0.1)}#downloadBtn{background:linear-gradient(135deg,#1d4ed8 0%,#3b82f6 100%)!important}#downloadBtn:hover{box-shadow:0 4px 12px rgba(29,78,216,0.3)}.highlight{background-color:#fff7ed;border-left:4px solid #f97316;padding:1rem;border-radius:.5rem}.faq-question{transition:all .3s ease}.faq-question:hover{transform:translateX(8px)}
        .crop-buttons-container{display:flex;justify-content:center;gap:16px;margin-top:10px}.crop-buttons-container button{min-width:140px;padding:20px;border-radius:8px;font-weight:600;transition:opacity .3s}
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QHR9LGCNE8"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-QHR9LGCNE8');
    </script>
</head>
<body class="flex flex-col items-center pt-8 pb-20">
    <div class="w-full max-w-4xl p-8 card rounded-2xl shadow-xl text-center mb-16 relative">
        <div class="absolute top-4 right-4 text-sm">
            <a href="/" class="text-blue-600 hover:text-gray-800">Espa√±ol</a>
            <span class="text-gray-400 mx-2">|</span>
            <a href="/index-en.html" class="text-gray-800">English</a>
        </div>
        <a href="https://datosargentinos.com" title="Safe ID - Share Your ID Securely - Datos Argentinos" class="mt-8 block">
            <img src="/logo.png" alt="Safe ID - Share Your ID Securely - Datos Argentinos" class="mx-auto mb-6 h-20 transform hover:scale-105 transition-transform duration-300">
        </a>
        <h1 class="text-4xl font-bold mb-8 text-gray-800">Share Your ID Securely</h1>
        
        <!-- Step 1: Upload and Text -->
        <div id="step1" class="space-y-6 step-transition">
            <label class="custom-file-upload block">
                <input type="file" id="imageInput" accept=".jpg,.jpeg,.png" class="hidden">
                <svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <p class="text-lg text-gray-600">Drag your image or tap here to upload</p>
                <p class="text-sm text-gray-500 mt-2">Supports: JPG and PNG</p>
            </label>
            <div class="relative">
                <div class="relative">
                    <div class="relative">
                        <input type="text" id="watermarkText" maxlength="60" placeholder="Enter watermark text (max. 60 characters)" 
                            class="w-full p-4 pr-16 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all text-center text-lg">
                        <span class="absolute right-4 top-1/2 -translate-y-1/2 text-sm text-gray-500">
                            <span id="charCount">0</span>/60
                        </span>
                    </div>
                    <p class="mt-2 text-sm text-gray-600 bg-blue-50 p-3 rounded-lg">
                        <strong>Watermark Tip:</strong> For better security, include the recipient's full name and specific purpose (e.g., "For John Doe - Identity verification at XYZ Bank")
                    </p>
                </div>
            </div>
            <button id="nextToPreviewBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold hover:opacity-90">
                Next
            </button>
        </div>

        <!-- Step 2: Preview and Blur -->
        <div id="step2" class="hidden step-transition">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Preview and Data Obscuring</h2>
                <div class="canvas-container">
                    <canvas id="originalCanvas" class="w-full cursor-crosshair"></canvas>
                </div>
            </div>
            <div class="space-y-4">
                <button id="enableCropBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold" style="background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)">
                    Crop Image
                </button>
                <div id="cropControls" class="bg-blue-50 p-8 rounded-lg hidden">
                    <p class="text-sm font-medium text-blue-700 mb-8 text-center">Drag the blue corners to adjust the crop area.</p>
                    <div class="crop-buttons-container mt-4">
                        <button id="applyCropBtn" class="px-8 py-3 rounded-lg font-semibold text-white text-base hover:opacity-90 transition-all" style="background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); min-width: 140px; box-shadow: 0 2px 4px rgba(6, 182, 212, 0.2);">
                            Apply
                        </button>
                        <button id="cancelCropBtn" class="px-8 py-3 rounded-lg font-semibold text-white text-base hover:opacity-90 transition-all" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); min-width: 140px; box-shadow: 0 2px 4px rgba(75, 85, 99, 0.2);">
                            Cancel
                        </button>
                    </div>
                </div>
                <button id="enableBlurBtn" class="w-full blur-button gradient-button text-white py-4 rounded-lg text-lg font-semibold">
                    Obscure Data
                </button>
                <div id="blurControls" class="bg-purple-50 p-4 rounded-lg hidden">
                    <label class="block text-sm font-medium text-purple-700 mb-2">
                        Obscuring Intensity: <span id="blurValue">10</span>
                    </label>
                    <input type="range" id="blurIntensity" min="3" max="15" value="10" 
                        class="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer mb-4">
                    
                    <label class="block text-sm font-medium text-purple-700 mb-2">
                        Cursor Size: <span id="cursorSizeValue">10</span>px
                    </label>
                    <input type="range" id="cursorSize" min="5" max="50" value="10" 
                        class="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer">
                </div>
                <div id="blurInstructions" class="bg-purple-50 text-purple-700 p-4 rounded-lg" style="display: none;">
                    Click and drag to obscure sensitive areas, then apply the watermark
                </div>
                <button id="nextToWatermarkBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold">
                    Apply Watermark
                </button>
            </div>
        </div>

        <!-- Step 3: Final Result -->
        <div id="step3" class="hidden step-transition">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Final Result</h2>
                <div class="canvas-container">
                    <canvas id="canvas" class="w-full"></canvas>
                </div>
            </div>
            <button id="shareBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold mb-4" style="background: linear-gradient(135deg, #059669 0%, #10b981 100%)">
                Share Image
            </button>
            <button id="downloadBtn" class="w-full gradient-button text-white py-4 rounded-lg text-lg font-semibold">
                Download Image
            </button>
            <a href="#" id="startOverBtn" class="block mt-12 text-gray-600 hover:text-gray-800 text-base transition-colors duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Start Over
            </a>
        </div>
    </div>

    <!-- FAQ Section -->
    <div class="w-full max-w-4xl p-8 card rounded-2xl shadow-xl mt-8">
        <h2 class="text-2xl font-semibold text-gray-800 mb-8 text-center">Frequently Asked Questions</h2>
        <div class="space-y-6">
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Is it safe to use this tool?</h3>
                <p class="highlight">Yes, the watermark is processed locally in your browser. No images are uploaded to external servers, ensuring your data privacy.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Why should I protect my ID when sharing it?</h3>
                <p class="text-gray-600">Sharing your ID without protection can lead to identity theft and fraud. By adding a watermark and obscuring sensitive data, you significantly reduce these risks.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">What data should I obscure from my ID?</h3>
                <p class="text-gray-600">It's recommended to obscure the transaction number, barcodes, QR codes, and any other data that isn't necessary for the specific purpose of the procedure.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">What text should I use in the watermark?</h3>
                <p class="text-gray-600">It's recommended to include the recipient's name and specific purpose, for example: "For XYZ Bank - Identity verification - MM/DD/YYYY".</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Preview</h3>
                <p class="text-gray-600 mt-6">Slide to see the difference between the original image and the final result</p><br />
                    <div class="comparison-slider-wrapper">
                        <img src="/dni-after.png" alt="Image with watermark">
                        <div class="comparison-slider">
                            <img src="/dni-before.png" alt="Original image">
                        </div>
                        <div class="slider-handle"></div>
                    </div>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Are processed images valid for procedures?</h3>
                <p class="text-gray-600">Yes, as long as the main data (photo, name, ID number) is clearly visible. Check with the specific entity about their requirements.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Where can I see the project's source code?</h3>
                <p class="text-gray-600">The code is open source and available on <a href="https://github.com/Xyborg/datosargentinos.com" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:text-gray-800">GitHub</a>. You can review it, contribute, or report issues.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Can I use the tool without internet connection?</h3>
                <p class="text-gray-600">Yes, the tool is a PWA (Progressive Web App) that you can install on your device. Once installed, it works completely offline.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">How do I install the application on my device?</h3>
                <p class="text-gray-600">On desktop Chrome/Edge, click the installation icon in the address bar. On mobile devices, select "Add to Home Screen" from the browser menu. The app will install and you can access it directly from your desktop or home screen.</p>
            </div>
            <div class="faq-question">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">What are the advantages of installing the app?</h3>
                <p class="text-gray-600">By installing the app, you can access it faster, work offline, and have a smoother experience similar to a native application. It will also take up less cache space than using the web version.</p>
            </div>
        </div>
    </div>

    <footer class="w-full py-4 text-center text-gray-600 text-sm mt-auto">
        Developed by <a href="https://www.martinaberastegue.com" class="text-blue-600 hover:text-gray-800" target="_blank" rel="noopener noreferrer">Martin Aberastegue</a>.<br>
        Inspired by <a href="https://saferlayer.com" class="text-blue-600 hover:text-gray-800" target="_blank" rel="noopener noreferrer">Saferlayer.com</a> and adapted for Argentine ID use case.
    </footer>
    <a href="https://www.iubenda.com/privacy-policy/69980701" class="iubenda-white iubenda-noiframe iubenda-embed iubenda-noiframe" target="_blank" rel="noopener noreferrer" title="Privacy Policy">Privacy Policy</a><script type="text/javascript">(function (w,d) {var loader = function () {var s = d.createElement("script"), tag = d.getElementsByTagName("script")[0]; s.src="https://cdn.iubenda.com/iubenda.js"; tag.parentNode.insertBefore(s,tag);}; if(w.addEventListener){w.addEventListener("load", loader, false);}else if(w.attachEvent){w.attachEvent("onload", loader);}else{w.onload = loader;}})(window, document);</script>

    <script>
        /**
         * SAFE ID - ID Protection Tool
         * 
         * This tool processes images completely in the user's browser.
         * No images are uploaded to external servers.
         * All image and data processing is done locally.
         */

        // DOM element references for the user interface
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const nextToPreviewBtn = document.getElementById('nextToPreviewBtn');
        const nextToWatermarkBtn = document.getElementById('nextToWatermarkBtn');
        const enableBlurBtn = document.getElementById('enableBlurBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const blurInstructions = document.getElementById('blurInstructions');
        
        /**
         * Canvas configuration for image processing
         * Two canvases are used:
         * - originalCanvas: maintains the original image with obscured areas
         * - canvas: shows the final result with watermark
         * 
         * willReadFrequently: true -> Optimizes performance for frequent pixel read operations
         */
        const originalCanvas = document.getElementById('originalCanvas');
        const originalCtx = originalCanvas.getContext('2d', { willReadFrequently: true });
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // State variables for application control
        let img = new Image();           // Stores the loaded image
        let painting = false;            // Controls painting/obscuring state
        let blurEnabled = false;         // Controls if blur mode is active
        
        /**
         * Quality settings for image processing
         * Ensures images maintain the best possible quality during processing
         */
        originalCtx.imageSmoothingEnabled = true;
        originalCtx.imageSmoothingQuality = 'high';
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        /**
         * Character counter system for watermark
         * Limits and displays the number of characters entered (maximum 60)
         */
        const watermarkInput = document.getElementById('watermarkText');
        const charCount = document.getElementById('charCount');
        
        watermarkInput.addEventListener('input', function() {
            charCount.textContent = this.value.length;
        });

        /**
         * Image loader handler
         * - Validates file type (JPG and PNG only)
         * - Processes image locally without sending to any server
         * - Shows preview in interface
         */
        document.getElementById('imageInput').addEventListener('change', function(e) {
            if (e.target.files[0]) {
                const file = e.target.files[0];
                const fileLabel = this.parentElement.querySelector('p');
                
                // Security validation: only allows safe image formats
                const validTypes = ['image/jpeg', 'image/jpg', 'image/png'];
                if (!validTypes.includes(file.type)) {
                    alert('Please upload a JPG or PNG file');
                    this.value = ''; // Clears input for security
                    return;
                }
                
                fileLabel.textContent = file.name;
                
                // Local image processing for preview
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewImg = document.createElement('img');
                    previewImg.src = e.target.result;
                    previewImg.classList.add('mx-auto', 'mt-4', 'max-h-40', 'rounded-lg');
                    
                    const existingPreview = fileLabel.parentElement.querySelector('img');
                    if (existingPreview) {
                        existingPreview.remove();
                    }
                    
                    fileLabel.parentElement.appendChild(previewImg);
                };
                reader.readAsDataURL(file);
            }
        });

        /**
         * Step transition system
         * Handles visibility and animations between different process stages
         */
        function showStep(stepToShow) {
            [step1, step2, step3].forEach(step => {
                if (step === stepToShow) {
                    step.classList.remove('hidden');
                    step.classList.add('step-enter');
                    setTimeout(() => step.classList.add('step-enter-active'), 10);
                } else {
                    step.classList.add('hidden');
                    step.classList.remove('step-enter', 'step-enter-active');
                }
            });
        }

        /**
         * Secure image loader
         * - Processes image maintaining original dimensions
         * - Does not reduce image quality
         * - Keeps all processing on user's device
         */
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                img = new Image();
                img.onload = function () {
                    // Maintains original dimensions to not lose quality
                    originalCanvas.width = canvas.width = img.width;
                    originalCanvas.height = canvas.height = img.height;
                    originalCtx.drawImage(img, 0, 0, img.width, img.height);
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    
                    // Adjusts visual size maintaining proportion
                    originalCanvas.style.width = canvas.style.width = '100%';
                    originalCanvas.style.height = canvas.style.height = 'auto';
                    originalCanvas.style.maxWidth = canvas.style.maxWidth = '100%';
                };
                img.onerror = function() {
                    alert('Error loading image. Please try another file.');
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                alert('Error reading file. Please try again.');
            };
            reader.readAsDataURL(file);
        }

        /**
         * Initial step validation and processing
         * Verifies that all necessary data has been provided
         */
        nextToPreviewBtn.addEventListener('click', () => {
            const imageInput = document.getElementById('imageInput');
            const watermarkText = watermarkInput.value;
            
            if (!imageInput.files[0]) {
                alert('Please upload an image first.');
                return;
            }
            if (!watermarkText.trim()) {
                alert('Please enter watermark text.');
                return;
            }
            if (watermarkText.length > 60) {
                alert('Watermark text must be 60 characters or less.');
                return;
            }

            loadImage(imageInput.files[0]);
            showStep(step2);
        });

        /**
         * Image cropping system
         * Allows user to select and crop a specific portion of the image
         */
        let cropEnabled = false;
        let cropBox = null;
        let originalImageData = null;
        let corners = [];

        // DOM elements for cropping
        const enableCropBtn = document.getElementById('enableCropBtn');
        const cropControls = document.getElementById('cropControls');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');

        function createCropBox() {
            cropBox = document.createElement('div');
            cropBox.style.position = 'absolute';
            cropBox.style.width = '100%';
            cropBox.style.height = '100%';
            cropBox.style.top = '0';
            cropBox.style.left = '0';
            cropBox.style.pointerEvents = 'none';
            
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.style.position = 'absolute';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.pointerEvents = 'none';
            
            // Set the SVG viewport
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('preserveAspectRatio', 'none');
            
            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            polygon.setAttribute('fill', 'rgba(6, 182, 212, 0.1)');
            polygon.setAttribute('stroke', '#06b6d4');
            polygon.setAttribute('stroke-width', '0.5');
            polygon.style.pointerEvents = 'none';
            svg.appendChild(polygon);
            cropBox.appendChild(svg);
            
            const canvasContainer = originalCanvas.parentElement;
            canvasContainer.style.position = 'relative';
            canvasContainer.appendChild(cropBox);

            // Calculate initial corner positions with padding relative to canvas size
            const rect = originalCanvas.getBoundingClientRect();
            const padding = Math.min(rect.width, rect.height) * 0.1; // 10% padding
            
            // Store corners in relative coordinates (0-1) for better scaling
            corners = [
                { x: padding / rect.width, y: padding / rect.height }, // Top-left
                { x: (rect.width - padding) / rect.width, y: padding / rect.height }, // Top-right
                { x: (rect.width - padding) / rect.width, y: (rect.height - padding) / rect.height }, // Bottom-right
                { x: padding / rect.width, y: (rect.height - padding) / rect.height } // Bottom-left
            ];

            // Create corner handles
            corners.forEach((corner, index) => {
                const handle = document.createElement('div');
                handle.className = 'corner-handle';
                handle.style.position = 'absolute';
                handle.style.width = '20px'; // Increased size for better touch
                handle.style.height = '20px'; // Increased size for better touch
                handle.style.backgroundColor = '#06b6d4';
                handle.style.border = '2px solid white';
                handle.style.borderRadius = '50%';
                handle.style.cursor = 'move';
                handle.style.zIndex = '10';
                handle.style.transform = 'translate(-50%, -50%)';
                handle.style.pointerEvents = 'auto';
                handle.style.touchAction = 'none'; // Prevent scrolling while dragging
                
                // Position the handle using relative coordinates
                handle.style.left = `${corner.x * 100}%`;
                handle.style.top = `${corner.y * 100}%`;
                
                // Mouse Events
                handle.addEventListener('mousedown', handleDragStart);
                
                // Touch Events
                handle.addEventListener('touchstart', handleDragStart, { passive: false });
                
                function handleDragStart(e) {
                    e.preventDefault(); // Prevent scrolling on mobile
                    e.stopPropagation();
                    const rect = originalCanvas.getBoundingClientRect();
                    
                    function moveHandle(e) {
                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                        
                        const x = Math.min(Math.max(0, (clientX - rect.left) / rect.width), 1);
                        const y = Math.min(Math.max(0, (clientY - rect.top) / rect.height), 1);
                        
                        corners[index] = { x, y };
                        handle.style.left = `${x * 100}%`;
                        handle.style.top = `${y * 100}%`;
                        
                        updatePolygon();
                    }
                    
                    function stopMoving() {
                        document.removeEventListener('mousemove', moveHandle);
                        document.removeEventListener('mouseup', stopMoving);
                        document.removeEventListener('touchmove', moveHandle);
                        document.removeEventListener('touchend', stopMoving);
                    }
                    
                    document.addEventListener('mousemove', moveHandle);
                    document.addEventListener('mouseup', stopMoving);
                    document.addEventListener('touchmove', moveHandle, { passive: false });
                    document.addEventListener('touchend', stopMoving);
                }
                
                cropBox.appendChild(handle);
            });
            
            updatePolygon();
        }

        function updatePolygon() {
            if (!cropBox) return;
            
            const polygon = cropBox.querySelector('polygon');
            if (polygon) {
                // Convert relative coordinates to SVG viewport coordinates (0-100)
                const pointsStr = corners.map(corner => {
                    const x = corner.x * 100;
                    const y = corner.y * 100;
                    return `${x},${y}`;
                }).join(' ');
                polygon.setAttribute('points', pointsStr);
            }
        }

        function disableCropMode() {
            cropEnabled = false;
            enableCropBtn.classList.remove('opacity-75');
            cropControls.classList.add('hidden');
            enableCropBtn.textContent = 'Crop Image'; // Ensure button text is updated
            
            if (cropBox) {
                cropBox.remove();
                cropBox = null;
            }
        }

        function enableCropMode() {
            cropEnabled = true;
            enableCropBtn.classList.add('opacity-75');
            cropControls.classList.remove('hidden');
            originalImageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            createCropBox();
            
            // Disable blur mode if it's active
            if (blurEnabled) {
                blurEnabled = false;
                blurInstructions.style.display = 'none';
                blurControls.classList.add('hidden');
                enableBlurBtn.textContent = 'Blur Data';
                enableBlurBtn.classList.remove('opacity-75');
            }
        }

        function applyCrop() {
            if (!cropBox) return;
            
            // Calculate the bounds of the cropped area
            const points = corners.map(corner => ({
                x: corner.x * originalCanvas.width,
                y: corner.y * originalCanvas.height
            }));
            
            // Find the bounding box of the cropped area
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            
            // Calculate new dimensions
            const newWidth = maxX - minX;
            const newHeight = maxY - minY;
            
            // Create a temporary canvas for the original image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalCanvas.width;
            tempCanvas.height = originalCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw the original image
            tempCtx.drawImage(originalCanvas, 0, 0);
            
            // Resize the original canvas to the new dimensions
            originalCanvas.width = newWidth;
            originalCanvas.height = newHeight;
            
            // Clear and set up the clipping path
            originalCtx.clearRect(0, 0, newWidth, newHeight);
            originalCtx.save();
            originalCtx.beginPath();
            
            // Adjust points relative to the new origin (minX, minY)
            points.forEach((point, index) => {
                const x = point.x - minX;
                const y = point.y - minY;
                if (index === 0) {
                    originalCtx.moveTo(x, y);
                } else {
                    originalCtx.lineTo(x, y);
                }
            });
            
            originalCtx.closePath();
            originalCtx.clip();
            
            // Draw the cropped portion of the original image
            originalCtx.drawImage(tempCanvas, -minX, -minY);
            originalCtx.restore();
            
            // Update canvas style to maintain aspect ratio
            originalCanvas.style.width = '100%';
            originalCanvas.style.height = 'auto';
            originalCanvas.style.maxWidth = '100%';
            
            disableCropMode();
            enableCropBtn.textContent = 'Crop Image'; // Update button text after applying crop
        }

        // Event listeners for cropping
        enableCropBtn.addEventListener('click', () => {
            if (cropEnabled) {
                if (originalImageData) {
                    originalCtx.putImageData(originalImageData, 0, 0);
                }
                disableCropMode();
                enableCropBtn.textContent = 'Crop Image';
            } else {
                enableCropMode();
                enableCropBtn.textContent = 'Disable Crop Mode';
            }
        });

        applyCropBtn.addEventListener('click', applyCrop);
        cancelCropBtn.addEventListener('click', () => {
            if (originalImageData) {
                originalCtx.putImageData(originalImageData, 0, 0);
            }
            disableCropMode();
        });

        // Update the crop controls text
        const cropInstructions = document.querySelector('#cropControls p');
        cropInstructions.textContent = 'Drag the blue corners to adjust the crop area.';

        /**
         * Blur control system
         * Allows user to adjust blur effect intensity
         */
        const blurIntensity = document.getElementById('blurIntensity');
        const blurValue = document.getElementById('blurValue');
        const cursorSize = document.getElementById('cursorSize');
        const cursorSizeValue = document.getElementById('cursorSizeValue');
        const blurControls = document.getElementById('blurControls');

        blurIntensity.addEventListener('input', function() {
            blurValue.textContent = this.value;
        });

        cursorSize.addEventListener('input', function() {
            cursorSizeValue.textContent = this.value;
        });

        /**
         * Blur mode control
         * Activates/deactivates ability to blur sensitive areas
         */
        enableBlurBtn.addEventListener('click', () => {
            blurEnabled = !blurEnabled;
            blurInstructions.style.display = blurEnabled ? 'block' : 'none';
            blurControls.classList.toggle('hidden');
            enableBlurBtn.textContent = blurEnabled ? 'Disable Blur Mode' : 'Blur Data';
            enableBlurBtn.classList.toggle('opacity-75');
            
            if (blurEnabled && 'ontouchstart' in window) {
                blurInstructions.textContent = 'Touch and drag to blur sensitive areas, then apply watermark';
            }
        });

        // Step navigation
        nextToWatermarkBtn.addEventListener('click', () => {
            showStep(step3);
            applyWatermark();
        });

        startOverBtn.addEventListener('click', () => {
            location.reload();
        });

        /**
         * Secure download system
         * Generates final image on user's device
         * No uploads to external servers
         */
        document.getElementById('downloadBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'safeid_datosargentinoscom.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        /**
         * Share system
         * Uses Web Share API to share image
         * Only available on compatible browsers and devices
         */
        document.getElementById('shareBtn').addEventListener('click', async () => {
            try {
                // Convert canvas to Blob for sharing
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                // Create file from blob for sharing
                const file = new File([blob], 'safeid_datosargentinoscom.png', { type: 'image/png' });

                // Check if browser supports Web Share API
                if (navigator.share) {
                    await navigator.share({
                        title: 'Protected ID',
                        text: 'ID with watermark and protected data via datosargentinos.com',
                        files: [file]
                    });
                } else {
                    // Fallback: If no Web Share API support, download the image
                    const link = document.createElement('a');
                    link.download = 'safeid_datosargentinoscom.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            } catch (error) {
                console.error('Error sharing:', error);
                // If error in sharing process, try direct download
                const link = document.createElement('a');
                link.download = 'safeid_datosargentinoscom.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        });

        /**
         * Interactive blur system
         * Implements mouse and touch events to allow user
         * to blur specific areas of the image interactively
         */

        // Mouse events for blurring
        originalCanvas.addEventListener('mousedown', (event) => {
            if (blurEnabled) {
                painting = true;
                blurAtMouse(event);
            }
        });
        
        originalCanvas.addEventListener('mouseup', () => painting = false);
        originalCanvas.addEventListener('mousemove', (event) => {
            if (painting && blurEnabled) {
                blurAtMouse(event);
            }
        });

        // Touch events for blurring on mobile devices
        originalCanvas.addEventListener('touchstart', (event) => {
            if (blurEnabled) {
                event.preventDefault(); // Prevent scroll while blurring
                painting = true;
                blurAtTouch(event);
            }
        });

        originalCanvas.addEventListener('touchend', (event) => {
            event.preventDefault();
            painting = false;
        });

        originalCanvas.addEventListener('touchmove', (event) => {
            if (painting && blurEnabled) {
                event.preventDefault(); // Prevent scroll while blurring
                blurAtTouch(event);
            }
        });

        /**
         * Position calculation functions for blurring
         * Convert screen coordinates to canvas coordinates
         * considering element scaling and position
         */
        function blurAtMouse(event) {
            // Get current canvas dimensions and position
            const rect = originalCanvas.getBoundingClientRect();
            // Calculate scale factors to maintain precision
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            // Convert mouse coordinates to canvas coordinates
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            applyBlur(x, y);
        }

        function blurAtTouch(event) {
            // Get current canvas dimensions and position
            const rect = originalCanvas.getBoundingClientRect();
            // Calculate scale factors to maintain precision
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            // Get first touch point
            const touch = event.touches[0];
            // Convert touch coordinates to canvas coordinates
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            applyBlur(x, y);
        }

        /**
         * Blur algorithm
         * Implements a gaussian blur effect to protect sensitive information
         * Process is irreversible and performed locally on device
         * @param {number} x - X coordinate of blur area center
         * @param {number} y - Y coordinate of blur area center
         */
        function applyBlur(x, y) {
            // Get blur brush radius from user control
            const radius = parseInt(cursorSize.value);
            const diameter = radius * 2;
            
            // Get image data for area to blur
            const imageData = originalCtx.getImageData(x - radius, y - radius, diameter, diameter);
            const pixels = imageData.data;
            const centerX = radius;
            const centerY = radius;
            
            // Apply blur effect to each pixel within radius
            for (let i = 0; i < diameter; i++) {
                for (let j = 0; j < diameter; j++) {
                    const idx = (i * diameter + j) * 4;
                    const distance = Math.sqrt(Math.pow(i - centerX, 2) + Math.pow(j - centerY, 2));
                    
                    // Only apply blur to pixels within circular radius
                    if (distance <= radius) {
                        const neighbors = getNeighborPixels(pixels, i, j, diameter);
                        pixels[idx] = neighbors.r;     // Red Channel
                        pixels[idx + 1] = neighbors.g; // Green Channel
                        pixels[idx + 2] = neighbors.b; // Blue Channel
                    }
                }
            }
            
            // Update canvas with blurred pixels
            originalCtx.putImageData(imageData, x - radius, y - radius);
        }

        /**
         * Helper function for blur calculation
         * Averages neighboring pixels to create gaussian blur effect
         * @param {Uint8ClampedArray} pixels - Pixel data array
         * @param {number} x - X coordinate of center pixel
         * @param {number} y - Y coordinate of center pixel
         * @param {number} diameter - Blur area diameter
         * @returns {Object} Averaged RGB values for pixel
         */
        function getNeighborPixels(pixels, x, y, diameter) {
            // Get blur intensity from slider control
            const intensity = parseInt(blurIntensity.value);
            const neighbors = {
                r: 0, // Sum of red values
                g: 0, // Sum of green values
                b: 0, // Sum of blue values
                count: 0 // Counter of processed pixels
            };

            // Process neighboring pixels based on intensity
            for (let i = -intensity; i <= intensity; i++) {
                for (let j = -intensity; j <= intensity; j++) {
                    const newX = x + i;
                    const newY = y + j;
                    
                    // Verify pixel is within valid area
                    if (newX >= 0 && newX < diameter && newY >= 0 && newY < diameter) {
                        const neighborIdx = (newX * diameter + newY) * 4;
                        neighbors.r += pixels[neighborIdx];     // Add red value
                        neighbors.g += pixels[neighborIdx + 1]; // Add green value
                        neighbors.b += pixels[neighborIdx + 2]; // Add blue value
                        neighbors.count++;
                    }
                }
            }

            // Return average of RGB values
            return {
                r: neighbors.r / neighbors.count,
                g: neighbors.g / neighbors.count,
                b: neighbors.b / neighbors.count
            };
        }

        /**
         * Watermark system
         * Applies a visible and persistent watermark to the image
         * Process is irreversible and done in multiple layers
         * to prevent watermark removal
         */
        function applyWatermark() {
            // Get watermark text
            const watermarkText = watermarkInput.value;
            
            // Adjust final canvas dimensions
            canvas.width = originalCanvas.width;
            canvas.height = originalCanvas.height;
            
            // Clear canvas and draw processed image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalCanvas, 0, 0);
            
            // Maintain aspect ratio in display
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            canvas.style.maxWidth = '100%';
            
            // Convert image to grayscale for better watermark visibility
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = data[i + 1] = data[i + 2] = avg;
            }
            ctx.putImageData(imageData, 0, 0);

            // Calculate adaptive font size
            const minFontSize = 16;
            const maxFontSize = 32;
            const baseFontSize = Math.min(canvas.width, canvas.height) / 30;
            const fontSize = Math.min(maxFontSize, Math.max(minFontSize, baseFontSize));
            
            // Configure text style
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            
            // Calculate spacing for watermark pattern
            const textWidth = ctx.measureText(watermarkText).width;
            const horizontalSpacing = textWidth * 1.2;
            const verticalSpacing = fontSize * 1.2;

            // Apply transformation for diagonal pattern
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(-Math.PI / 6);
            ctx.translate(-canvas.width/2, -canvas.height/2);

            // Calculate coverage area for watermark
            const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
            const startX = -diagonal/2;
            const startY = -diagonal/2;
            const endX = diagonal * 1.5;
            const endY = diagonal * 1.5;

            /**
             * Function to create wavy text effect
             * Adds variation and complexity to watermark
             * to make removal more difficult
             * @param {string} text - Text to draw
             * @param {number} x - Base X position of text
             * @param {number} y - Base Y position of text
             * @param {number} amplitude - Wave amplitude
             * @param {number} frequency - Wave frequency
             */
            const drawWavyText = (text, x, y, amplitude, frequency) => {
                const characters = text.split('');
                let currentX = x - (textWidth / 2);
                const baselineY = y;
                
                characters.forEach((char) => {
                    const charWidth = ctx.measureText(char).width;
                    const waveX = currentX + (charWidth / 2);
                    const yOffset = amplitude * Math.sin(frequency * waveX + baselineY * 0.05);
                    const xOffset = amplitude * 0.3 * Math.cos(frequency * waveX + baselineY * 0.05);
                    
                    // Shadow layer for better readability
                    ctx.globalAlpha = 0.1;
                    ctx.fillText(char, currentX + xOffset + 1, baselineY + yOffset + 1);
                    
                    // Main text layer
                    ctx.globalAlpha = 0.35;
                    ctx.fillText(char, currentX + xOffset, baselineY + yOffset);
                    
                    currentX += charWidth * 1.1;
                });
            };

            // Color palette for watermark
            // Semi-transparent colors for better visual integration
            const colors = [
                'rgba(230, 110, 110, 0.7)',  // Light red
                'rgba(140, 171, 111, 0.7)',  // Olive green
                'rgba(230, 110, 110, 0.7)',  // Light red
                'rgba(140, 171, 111, 0.7)',  // Olive green
                'rgba(124, 128, 194, 0.7)',  // Grayish blue
                'rgba(186, 85, 211, 0.7)',   // Purple
                'rgba(255, 165, 0, 0.7)',    // Orange
                'rgba(75, 0, 130, 0.7)',     // Indigo
                'rgba(64, 224, 208, 0.7)',   // Turquoise
                'rgba(255, 20, 147, 0.7)',   // Deep pink
                'rgba(255, 215, 0, 0.7)',    // Gold
                'rgba(0, 128, 128, 0.7)',    // Teal
                'rgba(219, 112, 147, 0.7)',  // Pale pink
                'rgba(106, 90, 205, 0.7)',   // Slate blue
                'rgba(255, 99, 71, 0.7)',    // Tomato
                'rgba(147, 112, 219, 0.7)',  // Medium purple
                'rgba(60, 179, 113, 0.7)',   // Medium sea green
                'rgba(238, 130, 238, 0.7)',  // Violet
                'rgba(218, 165, 32, 0.7)',   // Dark gold
                'rgba(72, 209, 204, 0.7)',   // Medium turquoise
                'rgba(199, 21, 133, 0.7)',   // Medium magenta
                'rgba(255, 140, 0, 0.7)'     // Dark orange
            ];

            // Apply watermark pattern across the entire image
            for (let y = startY; y < endY; y += verticalSpacing) {
                // Alternate horizontal offset in each row to create interlaced pattern
                let offsetX = (Math.floor(y / verticalSpacing) % 2) * (horizontalSpacing / 2);
                
                for (let x = startX + offsetX; x < endX; x += horizontalSpacing) {
                    // Wave parameters for text
                    const amplitude = fontSize * 0.3;
                    const frequency = 0.02;
                    // Select random color for each text instance
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    drawWavyText(watermarkText, x, y, amplitude, frequency);
                }
            }

            // Restore canvas context and opacity
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        /**
         * Interactive visual comparison system
         * Implements a slider control that allows the user
         * to compare the original image with the protected version
         */
        const comparisonSlider = document.querySelector('.comparison-slider');
        const sliderHandle = document.querySelector('.slider-handle');
        let isSliderDragging = false;

        /**
         * Updates slider position and comparison display
         * based on mouse/touch position
         * @param {number} x - Horizontal cursor/touch position
         */
        function updateSliderPosition(x) {
            // Get container dimensions
            const rect = comparisonSlider.parentElement.getBoundingClientRect();
            // Calculate position limited to container width
            const position = Math.max(0, Math.min(x - rect.left, rect.width));
            // Convert to percentage
            const percentage = (position / rect.width) * 100;
            
            // Update slider and handle position
            comparisonSlider.style.width = `${percentage}%`;
            sliderHandle.style.left = `${percentage}%`;
            
            // Adjust original image to maintain alignment
            const originalImg = comparisonSlider.querySelector('img');
            originalImg.style.width = `${(100 / percentage) * 100}%`;
            originalImg.style.maxWidth = 'none';
        }

        // Mouse events for slider control
        sliderHandle.addEventListener('mousedown', () => isSliderDragging = true);
        document.addEventListener('mousemove', (e) => {
            if (isSliderDragging) updateSliderPosition(e.clientX);
        });
        document.addEventListener('mouseup', () => isSliderDragging = false);

        // Touch events for slider control
        sliderHandle.addEventListener('touchstart', () => isSliderDragging = true);
        document.addEventListener('touchmove', (e) => {
            if (isSliderDragging) updateSliderPosition(e.touches[0].clientX);
        });
        document.addEventListener('touchend', () => isSliderDragging = false);

        /**
         * Service Worker Registration
         * Enables offline functionality and PWA features
         * Allows the tool to work without internet connection
         */
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registered successfully:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Error registering Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html> 